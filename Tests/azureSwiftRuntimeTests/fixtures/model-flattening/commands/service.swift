// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

// ManagementClient is the resource Flattening for AutoRest
import Foundation
import azureSwiftRuntime
struct ModelFlatteningNamespace {
    // GetArray get External Resource as an Array
    public class GetArrayCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/array"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode([FlattenedProductData?]?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> [FlattenedProductProtocol?]? {
            return try client.execute(command: self) as! [FlattenedProductProtocol?]?
        }
    }

    // GetDictionary get External Resource as a Dictionary
    public class GetDictionaryCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/dictionary"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode([String:FlattenedProductData?]?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> [String:FlattenedProductProtocol?]? {
            return try client.execute(command: self) as! [String:FlattenedProductProtocol?]?
        }
    }

    // GetResourceCollection get External Resource as a ResourceCollection
    public class GetResourceCollectionCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/resourcecollection"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode(ResourceCollectionData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> ResourceCollectionProtocol? {
            return try client.execute(command: self) as! ResourceCollectionProtocol?
        }
    }

    // GetWrappedArray no need to have a route in Express server for this operation. Used to verify the type flattened is
    // not removed if it's referenced in an array
    public class GetWrappedArrayCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/wrappedarray"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode([ProductWrapperData?]?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> [ProductWrapperProtocol?]? {
            return try client.execute(command: self) as! [ProductWrapperProtocol?]?
        }
    }

    // PostFlattenedSimpleProduct put Flattened Simple Product with client flattening true on the parameter
    public class PostFlattenedSimpleProductCommand : BaseCommand {
        public var simpleBodyProduct :  SimpleProductProtocol?

        public override init() {
            super.init()
            self.method = "Post"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/customFlattening"
        }

        public override func preCall()  {
            self.body = simpleBodyProduct
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: simpleBodyProduct as! SimpleProductData?)
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode(SimpleProductData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> SimpleProductProtocol? {
            return try client.execute(command: self) as! SimpleProductProtocol?
        }
    }

    // PutArray put External Resource as an Array
    public class PutArrayCommand : BaseCommand {
        public var resourceArray :  [ResourceProtocol?]?

        public override init() {
            super.init()
            self.method = "Put"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/array"
            self.headerParameters = ["Content-Type":"application/json"]
        }

        public override func preCall()  {
            self.body = resourceArray
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: resourceArray as! [ResourceData?]?)
        }

        public func execute(client: RuntimeClient) throws -> Decodable? {
            return try client.execute(command: self)
        }
    }

    // PutDictionary put External Resource as a Dictionary
    public class PutDictionaryCommand : BaseCommand {
        public var resourceDictionary :  [String:FlattenedProductProtocol?]?

        public override init() {
            super.init()
            self.method = "Put"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/dictionary"
            self.headerParameters = ["Content-Type":"application/json"]
        }

        public override func preCall()  {
            self.body = resourceDictionary
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: resourceDictionary as! [String:FlattenedProductData?]?)
        }

        public func execute(client: RuntimeClient) throws -> Decodable? {
            return try client.execute(command: self)
        }
    }

    // PutResourceCollection put External Resource as a ResourceCollection
    public class PutResourceCollectionCommand : BaseCommand {
        public var resourceComplexObject :  ResourceCollectionProtocol?

        public override init() {
            super.init()
            self.method = "Put"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/resourcecollection"
            self.headerParameters = ["Content-Type":"application/json"]
        }

        public override func preCall()  {
            self.body = resourceComplexObject
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: resourceComplexObject as! ResourceCollectionData?)
        }

        public func execute(client: RuntimeClient) throws -> Decodable? {
            return try client.execute(command: self)
        }
    }

    // PutSimpleProduct put Simple Product with client flattening true on the model
    public class PutSimpleProductCommand : BaseCommand {
        public var simpleBodyProduct :  SimpleProductProtocol?

         public override init() {
            super.init()
            self.method = "Put"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/customFlattening"
            self.headerParameters = ["Content-Type":"application/json"]
        }

        public override func preCall()  {
            self.body = simpleBodyProduct
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: simpleBodyProduct as! SimpleProductData?)
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode(SimpleProductData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> SimpleProductProtocol? {
            return try client.execute(command: self) as! SimpleProductProtocol?
        }
    }

    // PutSimpleProductWithGrouping put Simple Product with client flattening true on the model
    public class PutSimpleProductWithGroupingCommand : BaseCommand {
        public var name : String?
        public var simpleBodyProduct :  SimpleProductProtocol?

        public override init() {
            super.init()
            self.method = "Put"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/customFlattening/parametergrouping/{name}/"
            self.headerParameters = ["Content-Type":"application/json"]
        }

        public override func preCall()  {
            if self.name != nil { pathParameters["{name}"] = String(describing: self.name!) }
            self.body = simpleBodyProduct
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: simpleBodyProduct as! SimpleProductData?)
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try JsonResponseDecoder.decode(SimpleProductData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> SimpleProductProtocol? {
            return try client.execute(command: self) as! SimpleProductProtocol?
        }
    }

    // PutWrappedArray no need to have a route in Express server for this operation. Used to verify the type flattened is
    // not removed if it's referenced in an array
    public class PutWrappedArrayCommand : BaseCommand {
        public var resourceArray :  [WrappedProductProtocol?]?

        public override init() {
            super.init()
            self.method = "Put"
            self.isLongRunningOperation = false
            self.path = "/model-flatten/wrappedarray"
            self.headerParameters = ["Content-Type":"application/json"]
        }

        public override func preCall()  {
            self.body = resourceArray
        }

        public override func encodeBody() throws -> Data? {
            return try JsonRequestEncoder.encode(encodable: resourceArray as! [WrappedProductData?]?)
        }

        public func execute(client: RuntimeClient) throws -> Decodable? {
            return try client.execute(command: self)
        }
    }
}
