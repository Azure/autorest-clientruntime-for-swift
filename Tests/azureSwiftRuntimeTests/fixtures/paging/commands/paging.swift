// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

// Paging is the long-running Operation for AutoRest
import Foundation
import azureSwiftRuntime
struct PagingNamespace {
    // GetMultiplePages a paging operation that includes a nextLink that has 10 pages
    public class GetMultiplePagesCommand : BaseCommand {

        public var clientRequestId : String? {
            set {
                if newValue != nil {
                    headerParameters["client-request-id"] = newValue!
                }else {
                    headerParameters["client-request-id"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "client-request-id" }) {
                    return headerParameters["client-request-id"]
                }else {
                    return nil
                }
            }
        }

        public var maxresults : String? {
            set {
                if newValue != nil {
                    headerParameters["maxresults"] = newValue!
                }else {
                    headerParameters["maxresults"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "maxresults" }) {
                    return headerParameters["maxresults"]
                }else {
                    return nil
                }
            }
        }

        public var timeout : String? {
            set {
                if newValue != nil {
                    headerParameters["timeout"] = newValue!
                }else {
                    headerParameters["timeout"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "timeout" }) {
                    return headerParameters["timeout"]
                }else {
                    return nil
                }
            }
        }       

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = firstPage
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetMultiplePagesFailure a paging operation that receives a 400 on the second call
    public class GetMultiplePagesFailureCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/multiple/failure"
        }

        public override func preCall()  {
        }


        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple/failure"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetMultiplePagesFailureUri a paging operation that receives an invalid nextLink
    public class GetMultiplePagesFailureUriCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            // self.path = "/paging/multiple/failureuri"
        }
        public override func preCall()  {
        }


        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple/failureuri"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetMultiplePagesFragmentNextLink a paging operation that doesn't return a full URL, just a fragment
    public class GetMultiplePagesFragmentNextLinkCommand : BaseCommand {
        public var tenant : String?
        public var apiVersion : String? = "1.0.0"

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/multiple/fragment/{tenant}"
        }

        public override func preCall()  {
            if self.tenant != nil { pathParameters["{tenant}"] = String(describing: self.tenant!) }
            if self.apiVersion != nil { queryParameters["api_version"] = String(describing: self.apiVersion!) }
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(OdataProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple/fragment/{tenant}"
        
        public func getFirstPage(client: RuntimeClient) throws -> OdataProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
        
        public func getNextPage(from result: OdataProductResultProtocol?, client: RuntimeClient) throws -> OdataProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.odatanextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
    }

    // GetMultiplePagesFragmentWithGroupingNextLink a paging operation that doesn't return a full URL, just a fragment with
    // parameters grouped
    public class GetMultiplePagesFragmentWithGroupingNextLinkCommand : BaseCommand {
        public var tenant : String?
        public var apiVersion : String? = "1.0.0"

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/multiple/fragmentwithgrouping/{tenant}"
        }

        public override func preCall()  {
            if self.tenant != nil { pathParameters["{tenant}"] = String(describing: self.tenant!) }
            if self.apiVersion != nil { queryParameters["api_version"] = String(describing: self.apiVersion!) }
        }


        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(OdataProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple/fragmentwithgrouping/{tenant}"
        
        public func getFirstPage(client: RuntimeClient) throws -> OdataProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
        
        public func getNextPage(from result: OdataProductResultProtocol?, client: RuntimeClient) throws -> OdataProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.odatanextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
    }

    // GetMultiplePagesRetryFirst a paging operation that fails on the first call with 500 and then retries and then get a
    // response including a nextLink that has 10 pages
    public class GetMultiplePagesRetryFirstCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/multiple/retryfirst"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
//        public func execute(client: RuntimeClient) throws -> ProductResultProtocol? {
//            return try client.execute(command: self) as! ProductResultProtocol?
//        }
        
        let firstPage = "/paging/multiple/retryfirst"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetMultiplePagesRetrySecond a paging operation that includes a nextLink that has 10 pages, of which the 2nd call
    // fails first with 500. The client should retry and finish all 10 pages eventually.
    public class GetMultiplePagesRetrySecondCommand : BaseCommand {

         public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/multiple/retrysecond"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> ProductResultProtocol? {
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        let firstPage = "/paging/multiple/retrysecond"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetMultiplePagesWithOffset a paging operation that includes a nextLink that has 10 pages
    public class GetMultiplePagesWithOffsetCommand : BaseCommand {
        public var offset : Int32?

        public var clientRequestId : String? {
            set {
                if newValue != nil {
                    headerParameters["client-request-id"] = newValue!
                }else {
                    headerParameters["client-request-id"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "client-request-id" }) {
                    return headerParameters["client-request-id"]
                } else {
                    return nil
                }
            }
        }

        public var maxresults : String? {
            set {
                if newValue != nil {
                    headerParameters["maxresults"] = newValue!
                }else {
                    headerParameters["maxresults"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "maxresults" }) {
                    return headerParameters["maxresults"]
                }else {
                    return nil
                }
            }
        }

        public var timeout : String? {
            set {
                if newValue != nil {
                    headerParameters["timeout"] = newValue!
                }else {
                    headerParameters["timeout"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "timeout" }) {
                    return headerParameters["timeout"]
                }else {
                    return nil
                }
            }
        }

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/multiple/withpath/{offset}"
        }

        public override func preCall()  {
            if self.offset != nil { pathParameters["{offset}"] = String(describing: self.offset!) }
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple/withpath/{offset}"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetOdataMultiplePages a paging operation that includes a nextLink in odata format that has 10 pages
    public class GetOdataMultiplePagesCommand : BaseCommand {

        public var clientRequestId : String? {
            set {
                if newValue != nil {
                    headerParameters["client-request-id"] = newValue!
                }else {
                    headerParameters["client-request-id"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "client-request-id" }) {
                    return headerParameters["client-request-id"]
                }else {
                    return nil
                }
            }
        }

        public var maxresults : String? {
            set {
                if newValue != nil {
                    headerParameters["maxresults"] = newValue!
                }else {
                    headerParameters["maxresults"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "maxresults" }) {
                    return headerParameters["maxresults"]
                }else {
                    return nil
                }
            }
        }

        public var timeout : String? {
            set {
                if newValue != nil {
                    headerParameters["timeout"] = newValue!
                }else {
                    headerParameters["timeout"] = nil
                }
            }
            get {
                if headerParameters.contains(where: { $0.key == "timeout" }) {
                    return headerParameters["timeout"]
                }else {
                    return nil
                }
            }
        }
        

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = firstPage
        }

        public override func preCall()  {
        }


        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(OdataProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/multiple/odata"
        
        public func getFirstPage(client: RuntimeClient) throws -> OdataProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
        
        public func getNextPage(from result: OdataProductResultProtocol?, client: RuntimeClient) throws -> OdataProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.odatanextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
    }

    // GetSinglePages a paging operation that finishes on the first call without a nextlink
    public class GetSinglePagesCommand : BaseCommand {

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultData?.self, from: data)
        }
        
        let firstPage = "/paging/single"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // GetSinglePagesFailure a paging operation that receives a 400 on the first call
    public class GetSinglePagesFailureCommand : BaseCommand {

         public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            //self.path = "/paging/single/failure"
        }

        public override func preCall()  {
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(ProductResultProtocol?.self, from: data)
        }
        
        let firstPage = "/paging/single/failure"
        
        public func getFirstPage(client: RuntimeClient) throws -> ProductResultProtocol? {
            self.path = self.firstPage
            return try client.execute(command: self) as! ProductResultProtocol?
        }
        
        public func getNextPage(from result: ProductResultProtocol?, client: RuntimeClient) throws -> ProductResultProtocol? {
            guard
                let productResult = result,
                let nextLink = productResult.nextLink,
                let nextLinkUrl = URL(string: nextLink) else {
                    return nil
            }
            
            self.path = nextLinkUrl.path
            return try client.execute(command: self) as! ProductResultProtocol?
        }
    }

    // NextFragment a paging operation that doesn't return a full URL, just a fragment
    public class NextFragmentCommand : BaseCommand {
        public var tenant : String?
        public var nextLink : String?
        public var apiVersion : String? = "1.0.0"

         public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            self.path = "/paging/multiple/fragment/{tenant}/{nextLink}"
        }

        public override func preCall()  {
            if self.tenant != nil { pathParameters["{tenant}"] = String(describing: self.tenant!) }
            if self.nextLink != nil { pathParameters["{nextLink}"] = String(describing: self.nextLink!) }
            if self.apiVersion != nil { queryParameters["api-version"] = String(describing: self.apiVersion!) }
        }


        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(OdataProductResultData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> OdataProductResultProtocol? {
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
    }

    // NextFragmentWithGrouping a paging operation that doesn't return a full URL, just a fragment
    public class NextFragmentWithGroupingCommand : BaseCommand {
        public var tenant : String?
        public var nextLink : String?
        public var apiVersion : String? = "1.0.0"

        public override init() {
            super.init()
            self.method = "Get"
            self.isLongRunningOperation = false
            self.path = "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
        }

        public override func preCall()  {
            if self.tenant != nil { pathParameters["{tenant}"] = String(describing: self.tenant!) }
            if self.nextLink != nil { pathParameters["{nextLink}"] = String(describing: self.nextLink!) }
            if self.apiVersion != nil { queryParameters["api-version"] = String(describing: self.apiVersion!) }
        }

        public override func returnFunc(data: Data) throws -> Decodable? {
            return try CoderFactory.decoder(for: .json).decode(OdataProductResultData?.self, from: data)
        }
        
        public func execute(client: RuntimeClient) throws -> OdataProductResultProtocol? {
            return try client.execute(command: self) as! OdataProductResultProtocol?
        }
    }

}
